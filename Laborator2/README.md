# Activity 2: Creating a Fidelity Poins platform.

## Solidity basics

### Memory locations

There are three types of memory locations:

• **storage**: is used to permanently store data on the blockchain. State variables are stored in storage and have lifetime limited to the lifetime of the contract. Contract storage acts as a public database, from which values can be read with no fees. However, storing is expensive in terms of gas cost. Storage data is visible to all functions.

• **memory**: is used for temporary data required for local processing within functions and is less expensive in terms of gas cost. For some parameters, for example for string parameters it is mandatory to specify memory location.  

• **calldata**: non-modifiable, non-persistent data; it is used for msg object and it’s the default location for parameters of external functions (functions that can only be called by other contracts).

### Solidity types

Solidity is statically typed, each variable has a type. Variables have default values, depending on their type.

Value types store variable value:

-	**Numeric types**: integers int/uint and fixed-point number fixed/unfixed. Fixed/unfixed are not fully supported.  

-	**Booleans**: bool possible values true/false.

-	**Addresses** address and payable address. Both address and payable address are 20 bytes vales of an Ethereum addresses and may be used to query balances, with member balance. Payable address has additional members: transfer and send. Payable addresses are addresses one can send eth to. To directly interact with contract code, address has members:  call, delegatecall and staticcall.

-	**Fixed size byte arrays**: bytes1, … bytes32. Fixed size byte arrays cost less than string in terms of gas.

-	**Enums** are user defined types that assign names to an integral constants starting from 0.

Reference types store variable location:

-	**mappings**: resembles hash tables. Each possible key exists, and it’s mapped to a default value (all bytes 0). 

    - 	Syntax for mapping declaration: 
mapping(KeyType KeyName? => ValueType ValueName?) 
KeyName and ValueName are optional. KeyType can be any built-in value type, bytes, string, or any contract or enum type. ValueType can be any type.

    -   keccak256 hash is used on key to look up the value mapped to the key.

    -	Mappings can only have storage data location.

-	**struct**: Custom defined types that group a set of variables.

-	**arrays** can have a compile-time fixed size, or a dynamic size. We may append elements in a dynamically sized array calling member push and get the size of the array accessing member length. The index of the first element of an array is 0. Array elements can be of any type, including mapping or struct.

-	**bytes** is used for arbitrary-length raw byte data

-	**string** is used for arbitrary-length string (UTF-8) data. 

### Contract structure and functions

Each contract may include:
-   state variables declarations,
-   struct types, enum types,
-   functions modifiers,
-   functions,
-   events,
-   errors.

State variables cannot be modified by an external account, but their value is accessible for reading. Modifier public adds a default getter method.

**Access modifiers**:

**external**: function can be called only from another contract or using this.  May not be specified for state variables.

**internal**: functions or state variables that may be accessed only within the contract and in derived contracts.

**private**: functions or state variables that may be accessed only within the contract.

**public**: functions or state variables that may be accessed by external user and by the contract. For public state variable a public getter is generated by default.

**Function modifiers**:

**view**:  a view function is one that doesn't modify the state of the blockchain. A view function does not contain:

-	Write state variables statements.

-	Emit event statements.

-	Sending of eth.

-	Creation of other contracts etc.

**pure**: functions that doesn't modify or read state variables. Pure functions usually include mathematical functions or formatting functions.



## Exercises
1. Extend the existing FidelityPoints smart contract with a new function called spendPoints.
   This function will allow registered users to use some of their accumulated points in exchange for future rewards (such as products or special promotions).

2. Add a new state variable called totalPoints, which stores the sum of all points currently held by users.
   Then, create an internal function that updates this variable whenever points are added or spent.

3. Use Remix IDE to compile and deploy FidelityPoints contract, then interact with its functions to verify that registration, earning, spending, and total point tracking work correctly.

4. Go to [infura](https://developer.metamask.io/) and create and API KEY for an RPC_URL. Add the variable SEPOLIA_RPC_URL and SEPOLIA_PRIVATE_KEY in an .env file located in the main folder of the hardhat project.

SEPOLIA_RPC_URL: an endpoint provided by Infura, Alchemy, or QuickNode that lets your Hardhat project talk to the blockchain.

SEPOLIA_PRIVATE_KEY: The private key of the Ethereum wallet that will deploy your contracts and sign transactions.

5. Deploy on Sepolia:

```
npx hardhat ignition deploy ignition/modules/FidelityPoints.ts --network sepolia
```

5. Check ingnition/deployments and  serach for the deployed contract on [Sepolia Testnet Explorer](https://sepolia.etherscan.io/)

6. Run test:

```
npx hardhat test .\test\FidelityPoints.ts
```
7. In Catalog.sol add a uint stock variable to Product and write functions:
- ```increaseStock(bytes32 code, uint amount)```
- ```decreaseStock(bytes32 code, uint amount)```

8. Extend the existing contract in Catalog.sol in order to link a product to a promotion so that only certain products are part of promotions. Hint you can use mappings and functions:
- ```function startProductPromo(bytes32 memory code, uint ndays, uint percent) external```
- ```function startPromoBatch(bytes32[] memory codes, uint ndays, uint percent) external```

9. Add a function to practice looping and returning filtered results.
- ```function getProducts(bool inStock, bool inPromo) public view returns (Product[] memory)```

10. Add a pure function at your choice.

### Docs: 

[Solidity docs](https://docs.soliditylang.org/en/v0.8.28/)

[Solidity docs pdf](https://docs.soliditylang.org/_/downloads/en/latest/pdf/)

[bytes 32 converter](https://web3-type-converter.onbrn.com/)